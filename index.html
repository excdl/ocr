<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<title>è­·ç…§ / å°èƒè­‰ OCR è¾¨è­˜</title>

<!-- OpenCV (async) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<!-- Tesseract OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<!-- MRZ å°ˆç”¨è¾¨è­˜ -->
<script src="https://cdn.jsdelivr.net/npm/mrz@3.0.0/dist/mrz.min.js"></script>

<style>
body {
  font-family: "Arial", sans-serif;
  background: #f2f2f2;
}

.container {
  width: 90%;
  max-width: 480px;
  margin: 20px auto;
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.15);
}

.upload-box {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
}

button {
  background: #007bff;
  color: white;
  border: none;
  padding: 12px;
  border-radius: 6px;
  cursor: pointer;
}

button:hover {
  background: #0056c1;
}

video {
  width: 100%;
  border-radius: 8px;
  margin: 10px 0;
  display: none;
}

pre {
  background: #222;
  color: #0f0;
  padding: 10px;
  border-radius: 8px;
  height: 180px;
  overflow-y: auto;
}
</style>

</head>
<body>

<div class="container">
    <h2>è­·ç…§ / å°èƒè­‰ OCR è¾¨è­˜</h2>

    <div class="upload-box">
        <input type="file" id="fileInput" accept="image/*" hidden>
        <button onclick="document.getElementById('fileInput').click()">ğŸ“¤ ä¸Šå‚³åœ–ç‰‡</button>

        <button id="cameraBtn">ğŸ“· ä½¿ç”¨ç›¸æ©Ÿ</button>
    </div>

    <video id="camera" autoplay playsinline></video>
    <button id="capture" style="display:none;">æ‹ç…§</button>

    <p id="status"></p>
    <pre id="result"></pre>
</div>

<script>
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxRw0sVVg_coQBE-JZi2a0WvsEXqCa7lf7u5viiR0qvVpEBWQ8vmCMCbsm5PmFBpLxL/exec";  // <<< ä½ è¦å¡«é€™å€‹ï¼

// ===============================
// å½±åƒå‰è™•ç† (OpenCV)
// ===============================
async function preprocessImage(blob) {
    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
            const c = document.createElement("canvas");
            c.width = img.width;
            c.height = img.height;
            const ctx = c.getContext("2d");
            ctx.drawImage(img, 0, 0);

            const src = cv.imread(c);

            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
            cv.threshold(src, src, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
            cv.GaussianBlur(src, src, new cv.Size(3,3), 0);

            const kernel = cv.Mat.ones(3, 3, cv.CV_32F);
            for (let i = 0; i < 9; i++) kernel.data32F[i] = -1;
            kernel.data32F[4] = 12; 
            cv.filter2D(src, src, cv.CV_8U, kernel);

            cv.imshow(c, src);

            src.delete();
            kernel.delete();

            c.toBlob(resolve, "image/jpeg");
        };
        img.src = URL.createObjectURL(blob);
    });
}

// ===============================
// è‡ªå‹•è£åˆ‡ MRZ å€åŸŸ
// ===============================
async function extractMRZ(blob) {
    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
            const h = img.height;
            const mrzY = h * 0.80;
            const mrzH = h * 0.20;

            const c = document.createElement("canvas");
            c.width = img.width;
            c.height = mrzH;

            c.getContext("2d").drawImage(
                img,
                0, mrzY, img.width, mrzH,
                0, 0, img.width, mrzH
            );

            c.toBlob(resolve, "image/jpeg");
        };
        img.src = URL.createObjectURL(blob);
    });
}

// ===============================
// å°ˆç”¨ MRZ è¾¨è­˜
// ===============================
async function recognizeMRZ(blob) {
    return new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = () => {
            let text = MRZ.parse(reader.result);
            resolve(text.valid ? text : null);
        };
        reader.readAsText(blob);
    });
}

// ===============================
// Tesseract è¾¨è­˜ (å°èƒè­‰)
// ===============================
async function recognizeOCR(blob) {
    const { data: { text } } = await Tesseract.recognize(blob, "eng");
    return text;
}

// ===============================
// ä¸»æµç¨‹
// ===============================
async function processImage(file) {
    status.innerText = "ğŸ›  æ­£åœ¨å¼·åŒ–å½±åƒ...";
    const processed = await preprocessImage(file);

    status.innerText = "ğŸ” å˜—è©¦è¾¨è­˜ MRZ(è­·ç…§)...";
    const mrzBlob = await extractMRZ(processed);
    const mrzData = await recognizeMRZ(mrzBlob);

    let data;

    // --- è­·ç…§ ---
    if (mrzData) {
        status.innerText = "ğŸ“˜ æˆåŠŸè¾¨è­˜è­·ç…§ï¼";

        data = {
            documentType: "Passport",
            name: mrzData.fields.surname + " " + mrzData.fields.givenNames,
            number: mrzData.fields.documentNumber,
            nationality: mrzData.fields.nationality,
            birthday: mrzData.fields.dateOfBirth
        };

    } else {
        // --- å°èƒè­‰ ---
        status.innerText = "ğŸ“„ ç„¡ MRZï¼Œè¾¨è­˜å°èƒè­‰...";
        const text = await recognizeOCR(processed);

        result.innerText = text;

        data = {
            documentType: "Taiwan Compatriot Permit",
            name: (text.match(/[\u4e00-\u9FFF]{2,}/) || [""])[0],
            number: (text.match(/[A-Z0-9]{6,}/) || [""])[0],
            nationality: "",
            birthday: ""
        };
    }

    // é€å‡ºè³‡æ–™
    status.innerText = "ğŸ“¤ æ­£åœ¨å¯«å…¥ Google Sheet...";
    await fetch(SCRIPT_URL, {
        method: "POST",
        body: JSON.stringify(data)
    });

    status.innerText = "ğŸ‰ å®Œæˆï¼è³‡æ–™å·²æˆåŠŸå¯«å…¥ Google Sheet";
}

// ===============================
// è§¸ç™¼å™¨ï¼šä¸Šå‚³åœ–ç‰‡
// ===============================
fileInput.onchange = e => processImage(e.target.files[0]);

// ===============================
// è§¸ç™¼å™¨ï¼šé–‹å•Ÿç›¸æ©Ÿ
// ===============================
const cameraBtn = document.getElementById("cameraBtn");
const camera = document.getElementById("camera");
const capture = document.getElementById("capture");
let stream;

cameraBtn.onclick = async () => {
    stream = await navigator.mediaDevices.getUserMedia({ video: true });
    camera.srcObject = stream;
    camera.style.display = "block";
    capture.style.display = "block";
};

capture.onclick = () => {
    const canvas = document.createElement("canvas");
    canvas.width = camera.videoWidth;
    canvas.height = camera.videoHeight;
    canvas.getContext("2d").drawImage(camera, 0, 0);
    canvas.toBlob(blob => processImage(blob));
};
</script>

</body>
</html>
