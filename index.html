<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<title>è­·ç…§ / å°èƒè­‰ OCR è¾¨è­˜</title>

<!-- OpenCV (async) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<!-- Tesseract OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

<!-- MRZ å°ˆç”¨è¾¨è­˜ -->
<script src="https://cdn.jsdelivr.net/npm/mrz@3.0.0/dist/mrz.min.js"></script>

<style>
body { font-family: "Arial"; background: #f2f2f2; }
.container {
  width: 90%; max-width: 480px; margin: 20px auto;
  padding: 20px; background: white; border-radius: 10px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.15);
}
.upload-box { display: flex; justify-content: space-between; }
button {
  background: #007bff; color: white; border: none;
  padding: 10px; border-radius: 6px; cursor: pointer;
}
button:hover { background: #0056c1; }
video { width: 100%; display: none; margin-top: 10px; border-radius: 10px; }
pre { background:#222; color:#0f0; padding:10px; border-radius:6px; height:160px;overflow-y:auto; }
</style>

</head>
<body>

<div class="container">
    <h2>è­·ç…§ / å°èƒè­‰ OCR è¾¨è­˜</h2>

    <div class="upload-box">
        <input type="file" id="fileInput" accept="image/*" hidden>
        <button onclick="document.getElementById('fileInput').click()">ğŸ“¤ ä¸Šå‚³åœ–ç‰‡</button>
        <button id="cameraBtn">ğŸ“· ä½¿ç”¨ç›¸æ©Ÿ</button>
    </div>

    <video id="camera" autoplay playsinline></video>
    <button id="capture" style="display:none;">æ‹ç…§</button>

    <p id="status"></p>
    <pre id="result"></pre>
</div>

<script>
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxRw0sVVg_coQBE-JZi2a0WvsEXqCa7lf7u5viiR0qvVpEBWQ8vmCMCbsm5PmFBpLxL/exec";   // â¬… ä¿®æ”¹é€™è£¡

let openCVReady = false;

// ==========================
// ç­‰å¾… OpenCV è¼‰å…¥
// ==========================
document.getElementById("status").innerText = "æ­£åœ¨è¼‰å…¥ OpenCVï¼Œè«‹ç¨å€™â€¦";

window.cv = window.cv || {};

cv.onRuntimeInitialized = () => {
    openCVReady = true;
    document.getElementById("status").innerText = "OpenCV è¼‰å…¥å®Œæˆï¼Œå¯é–‹å§‹ä¸Šå‚³åœ–ç‰‡ï¼";
};

// ==========================
// å½±åƒå‰è™•ç†
// ==========================
async function preprocessImage(blob) {
    if (!openCVReady) {
        alert("OpenCV å°šæœªè¼‰å…¥å®Œæˆï¼");
        return null;
    }

    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
            const c = document.createElement("canvas");
            c.width = img.width;
            c.height = img.height;
            const ctx = c.getContext("2d");
            ctx.drawImage(img, 0, 0);

            try {
                const src = cv.imread(c);

                cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
                cv.threshold(src, src, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
                cv.GaussianBlur(src, src, new cv.Size(3,3), 0);

                cv.imshow(c, src);
                src.delete();

                c.toBlob(resolve, "image/jpeg");
            } catch (err) {
                alert("OpenCV å½±åƒè™•ç†éŒ¯èª¤ï¼š" + err);
                resolve(blob);
            }
        };
        img.src = URL.createObjectURL(blob);
    });
}

// ==========================
// OCR ä¸»æµç¨‹
// ==========================
async function processImage(file) {
    if (!openCVReady) {
        alert("OpenCV å°šæœªè¼‰å…¥å®Œæˆï¼");
        return;
    }

    status.innerText = "ğŸ›  æ­£åœ¨å¼·åŒ–å½±åƒ...";
    const processed = await preprocessImage(file);

    status.innerText = "ğŸ” å˜—è©¦è¾¨è­˜ MRZ(è­·ç…§)...";

    // â†’ è£åˆ‡ MRZ
    const mrzBlob = await extractMRZ(processed);
    const mrz = await recognizeMRZ(mrzBlob);

    let data;

    if (mrz) {
        status.innerText = "ğŸ“˜ æˆåŠŸè¾¨è­˜è­·ç…§ MRZï¼";

        data = {
            documentType: "Passport",
            name: mrz.fields.surname + " " + mrz.fields.givenNames,
            number: mrz.fields.documentNumber,
            nationality: mrz.fields.nationality,
            birthday: mrz.fields.dateOfBirth
        };

    } else {
        status.innerText = "ğŸ“„ è¾¨è­˜å°èƒè­‰...";
        const text = await recognizeOCR(processed);

        result.innerText = text;

        data = {
            documentType: "Taiwan Compatriot Permit",
            name: (text.match(/[\u4e00-\u9FFF]{2,}/) || [""])[0],
            number: (text.match(/[A-Z0-9]{6,}/) || [""])[0],
            nationality: "",
            birthday: ""
        };
    }

    status.innerText = "ğŸ“¤ æ­£åœ¨å¯«å…¥ Google Sheetâ€¦";

    await fetch(SCRIPT_URL, {
        method: "POST",
        body: JSON.stringify(data)
    });

    status.innerText = "ğŸ‰ å·²æˆåŠŸå¯«å…¥ Google Sheetï¼";
}

// ==========================
// ç›£è½ä¸Šå‚³åœ–ç‰‡
// ==========================
fileInput.onchange = e => {
    if (e.target.files.length > 0) {
        processImage(e.target.files[0]);
    }
};

// ==========================
// ç›¸æ©ŸåŠŸèƒ½
// ==========================
const cameraBtn = document.getElementById("cameraBtn");
const camera = document.getElementById("camera");
const capture = document.getElementById("capture");

let stream;

cameraBtn.onclick = async () => {
    stream = await navigator.mediaDevices.getUserMedia({ video: true });
    camera.srcObject = stream;
    camera.style.display = "block";
    capture.style.display = "block";
};

capture.onclick = () => {
    const c = document.createElement("canvas");
    c.width = camera.videoWidth;
    c.height = camera.videoHeight;
    c.getContext("2d").drawImage(camera, 0, 0);
    c.toBlob(blob => processImage(blob));
};

// ==========================
// å·¥å…·ï¼šè£åˆ‡ MRZ å€åŸŸ
// ==========================
async function extractMRZ(blob) {
    return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
            const h = img.height;
            const mrzY = h * 0.80;
            const mrzH = h * 0.20;

            const c = document.createElement("canvas");
            c.width = img.width;
            c.height = mrzH;
            c.getContext("2d").drawImage(img, 0, mrzY, img.width, mrzH, 0, 0, img.width, mrzH);

            c.toBlob(resolve, "image/jpeg");
        };
        img.src = URL.createObjectURL(blob);
    });
}

// ==========================
// å·¥å…·ï¼šMRZ å°ˆç”¨è¾¨è­˜
// ==========================
async function recognizeMRZ(blob) {
    return new Promise(resolve => {
        const fr = new FileReader();
        fr.onload = () => {
            const parsed = MRZ.parse(fr.result);
            resolve(parsed.valid ? parsed : null);
        };
        fr.readAsText(blob);
    });
}

// ==========================
// å·¥å…·ï¼šTesseract è¾¨è­˜
// ==========================
async function recognizeOCR(blob) {
    const { data: { text } } = await Tesseract.recognize(blob, "eng");
    return text;
}

</script>

</body>
</html>



