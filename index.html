<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>è­·ç…§ / å°èƒè­‰ OCR App (GitHub Pages å‹å–„ç‰ˆ)</title>
<style>
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Arial;background:linear-gradient(135deg,#4facfe,#00f2fe);}
.container{width:92%;max-width:480px;margin:28px auto;background:white;border-radius:18px;padding:24px;box-shadow:0 12px 28px rgba(0,0,0,0.15);}
h2{text-align:center;color:#333;}
.upload-box{display:flex;gap:10px;margin-bottom:12px;}
button,label{background:#2979ff;color:white;border:none;padding:12px 18px;border-radius:12px;cursor:pointer;font-size:16px;flex:1;text-align:center;}
video,canvas{width:100%;border-radius:12px;display:none;margin-top:12px;}
#ocrPreview,pre{background:#222;color:#0f0;padding:12px;border-radius:10px;height:150px;overflow-y:auto;margin-top:12px;font-family:monospace;}
.close-preview{position:absolute;top:8px;right:8px;background:red;color:white;padding:2px 6px;border-radius:6px;cursor:pointer;font-size:14px;}
.preview-container{position:relative;}
</style>
</head>
<body>
<div class="container">
<h2>è­·ç…§ / å°èƒè­‰ OCR App</h2>
<div class="upload-box">
<input type="file" id="fileInput" accept="image/*" hidden>
<label id="uploadBtn" for="fileInput">ğŸ“¤ ä¸Šå‚³åœ–ç‰‡</label>
<button id="cameraBtn">ğŸ“· ä½¿ç”¨ç›¸æ©Ÿ</button>
</div>
<div class="preview-container">
<canvas id="previewCanvas"></canvas>
<div class="close-preview" id="closePreview" style="display:none;">Ã—</div>
</div>
<video id="camera" autoplay playsinline></video>
<button id="capture" style="display:none;margin-top:12px;">ğŸ“¸ æ‹ç…§</button>
<p id="status">åˆå§‹åŒ–ä¸­â€¦</p>
<pre id="result">è¾¨è­˜çµæœå°‡é¡¯ç¤ºæ–¼æ­¤</pre>
<pre id="ocrPreview">OCR é è¦½</pre>
</div>

<!-- Tesseract.js -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.3.1/dist/tesseract.min.js"></script>
<!-- MRZ -->
<script src="https://unpkg.com/mrz/dist/mrz.min.js"></script>
<!-- OpenCV -->
<script src="https://docs.opencv.org/4.9.0/opencv.js"></script>

<script>
let worker, workerReady=false;
const status=document.getElementById("status");
const resultPre=document.getElementById("result");
const ocrPreview=document.getElementById("ocrPreview");
const previewCanvas=document.getElementById("previewCanvas");
const closePreview=document.getElementById("closePreview");

// ===================== Tesseract åˆå§‹åŒ– =====================
async function initTesseract() {
    if(typeof Tesseract === 'undefined'){ 
        status.innerText="Tesseract æœªè¼‰å…¥ âŒ"; 
        return; 
    }

    worker = Tesseract.createWorker({
        logger: m => { if(m.status==='recognizing text' && m.progress) ocrPreview.innerText=m.text||''; },
        workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.3.1/dist/worker.min.js',
        corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@4.1.0/tesseract-core.wasm.js',
        langPath: 'https://tessdata.projectnaptha.com/4.0.0_best/'
    });

    try{
        status.innerText="è¼‰å…¥ Workerâ€¦";
        await worker.load();
        status.innerText="è¼‰å…¥èªè¨€â€¦";
        await worker.loadLanguage('eng+chi_tra+chi_sim');
        await worker.initialize('eng+chi_tra+chi_sim');
        await worker.setParameters({
            tessedit_char_whitelist:"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹é›¶abcdefghijklmnopqrstuvwxyz",
            tessedit_pageseg_mode:Tesseract.PSM.AUTO
        });
        workerReady=true;
        status.innerText="Tesseract åˆå§‹åŒ–å®Œæˆ âœ…";
    }catch(e){
        console.error("Tesseract åˆå§‹åŒ–å¤±æ•—:", e);
        status.innerText="Tesseract åˆå§‹åŒ–å¤±æ•— âŒ";
    }
}

// ===================== OpenCV åˆå§‹åŒ– =====================
if(typeof cv==='undefined'){
    status.innerText="OpenCV è¼‰å…¥å¤±æ•— âŒ";
}else{
    cv['onRuntimeInitialized']=()=>{ initTesseract(); };
}

// ===================== OCR =====================
async function processCanvas(canvas){
    if(!workerReady){ status.innerText="Tesseract å°šæœªåˆå§‹åŒ–"; return; }
    const ctx=previewCanvas.getContext('2d');
    previewCanvas.width=canvas.width;
    previewCanvas.height=canvas.height;
    ctx.drawImage(canvas,0,0);

    try{
        const { data:{ text } } = await worker.recognize(canvas);
        ocrPreview.innerText=text.trim().slice(0,300);

        let result={raw:text};
        let mrzText=text.replace(/\s/g,'');
        try{
            const mrz=MRZ.parse(mrzText);
            if(mrz.valid){
                result.documentType="Passport";
                result.name=mrz.fields.surname+" "+mrz.fields.givenNames;
                result.id=mrz.fields.documentNumber;
                result.nationality=mrz.fields.nationality;
                result.birthday=mrz.fields.dateOfBirth;
                result.expiry=mrz.fields.expirationDate;
                result.sex=mrz.fields.sex;
            }else{
                result.documentType="Taiwan Compatriot Permit";
                let lines=text.split(/\n/).map(l=>l.trim()).filter(l=>l);
                result.name=lines[0]||'';
                result.birthday=lines[1]||'';
                result.expiry=lines[2]||'';
            }
        }catch(e){ result.documentType="Unknown"; }
        resultPre.innerText=JSON.stringify(result,null,2);
    }catch(e){ console.error("OCR å¤±æ•—:",e); status.innerText="OCR å¤±æ•— âŒ"; }
}

// ===================== ä¸Šå‚³åœ–ç‰‡ =====================
document.getElementById("fileInput").onchange=e=>{
    if(e.target.files.length>0){
        const file=e.target.files[0];
        const img=new Image();
        img.onload=()=> processCanvas(img);
        img.src=URL.createObjectURL(file);
    }
};

// ===================== é è¦½æ§åˆ¶ =====================
closePreview.onclick=()=>{ previewCanvas.style.display='none'; closePreview.style.display='none'; document.getElementById("fileInput").value=''; };

// ===================== ç›¸æ©Ÿæ‹ç…§ =====================
const cameraBtn=document.getElementById("cameraBtn");
const camera=document.getElementById("camera");
const capture=document.getElementById("capture");
let liveOCRInterval=null;

cameraBtn.onclick=async()=>{
    try{
        const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
        camera.srcObject=stream;
        camera.style.display='block';
        capture.style.display='block';
        if(liveOCRInterval) clearInterval(liveOCRInterval);
        liveOCRInterval=setInterval(async()=>{
            if(!workerReady) return;
            processCanvas(camera);
        },500);
    }catch(e){ console.error(e); status.innerText="ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿ âŒ"; }
};

capture.onclick=async()=>{
    if(liveOCRInterval){ clearInterval(liveOCRInterval); liveOCRInterval=null; }
    processCanvas(camera);
};
</script>
</body>
</html>
















































